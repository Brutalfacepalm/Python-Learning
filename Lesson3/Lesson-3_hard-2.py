# Задание - 1
# Давайте опишем пару сущностей player и enemy через словарь,
# который будет иметь ключи и значения:
# name - строка полученная от пользователя,
# health - 100,
# damage - 50.
# Поэксперементируйте с значениями урона и жизней по желанию.
# Теперь надо создать функцию attack(person1, person2), аргументы можете указать свои,
# функция в качестве аргумента будет принимать атакующего и атакуемого,
# функция должна получить параметр damage атакующего и отнять это количество
# health от атакуемого. Функция должна сама работать с словарями и изменять их значения.

# Задание - 2
# Давайте усложним предыдущее задание, измените сущности, добавив новый параметр - armor = 1.2
# Теперь надо добавить функцию, которая будет вычислять и возвращать полученный урон по формуле damage / armor
# Следовательно у вас должно быть 2 функции, одна наносит урон, вторая вычисляет урон по отношению к броне.

# Сохраните эти сущности, полностью, каждую в свой файл,
# в качестве названия для файла использовать name, расширение .txt
# Напишите функцию, которая будет считывать файл игрока и его врага, получать оттуда данные, и записывать их в словари,
# после чего происходит запуск игровой сессии, где сущностям поочередно наносится урон,
# пока у одного из них health не станет меньше или равен 0.
# После чего на экран должно быть выведено имя победителя, и количество оставшихся единиц здоровья.
####-------------------------
# не понял по условию задачи нужно ли в коде создавать словарь, записывать его в файл и потом опять с него читать, поэтому не стал
# этого делать, а просто запихнул сущности в файлы вручную(точнее один раз прогнав код ниже) и считываю с них данные
#
# player = {'name': input('Как вас зовут? '), 'health': 140, 'damage': 10, 'armor': 1.5}  # описние словарем сущности игрока
# enemy = {'name': input('Как зовут вашего противника? '), 'health': 100, 'damage': 7, 'armor': 1.2} # описние словарем сущности противника
#
# with open(player['name']+'.txt', 'w', encoding='utf-8') as file:
#     for k, v in player.items():
#         file.write('{} - {}\n'.format(k, v))
# with open(enemy['name']+'.txt', 'w', encoding='utf-8') as file:
#     for k, v in enemy.items():
#         file.write('{} - {}\n'.format(k, v))
#
def attack(attacking, attacked): # высчитывает урон от брони
    return attacking['damage'] / attacked['armor']

def battle(attacking, attacked): # наносит урон
    attacked['health'] -= attack(attacking, attacked)

def read_files(file_name, player): # считываются данные, на вход подается имя файла и пустой список иргока или противника
    with open(file_name + '.txt', 'r', encoding='utf-8') as file: # открывается файл по переданному имени файла
        for param in file: # построчно считывается, затем каждая строка разделяется на список, проверяется значение
            param = param.strip().split(' - ') # на число, и в случае истины приводится к типу float
            if param[1].isalpha() == False:
                param[1] = float(param[1])
            player.append(param) # затем записывается как вложенный список в исходный
    return player

def players_read_and_battle():
    player = []
    enemy = []
    read_files('Ant', player) # считываются данные игрока
    player = dict(player) # создается словарь для игрока
    read_files('Alex', enemy) # считываются данные противника
    enemy = dict(enemy) # создается словарь для противника

    while player['health'] > 0 and enemy['health'] > 0: # запускается цикл, работает пока XP любого из игроков не опустится ниже 0
        battle(player, enemy) # атакующий - игрок, атакуемый - противник
        if player['health'] <= 0 or enemy['health'] <= 0:
            break
        battle(enemy, player) # атакующий - противник, атакуемый - игрок

    if player['health'] <= 0: # если умер игрок ->
        return 'Выиграл {}, у него осталось {} единиц здоровья.'.format(enemy['name'], round(enemy['health'], 2))
    elif enemy['health'] <= 0: # если умер противник ->
        return 'Выиграл {}, у него осталось {} единиц здоровья.'.format(player['name'], round(player['health'], 2))

print(players_read_and_battle()) # основная функция, считывает данные, создает словари, запускает битву, передает результат